#!/usr/bin/env node
import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import * as fs from 'fs';
import * as path from 'path';
import { TradingCodeGenerator } from '@crowelang/compiler';
import { BacktestEngine, BaseStrategy } from '@crowelang/runtime';

const program = new Command();

program
  .name('crowelang')
  .description('CroweLang CLI - Quantitative Trading DSL')
  .version('0.1.0');

// Compile command
program
  .command('compile <file>')
  .description('Compile a CroweLang strategy file')
  .option('-t, --target <target>', 'Target language (python|typescript|cpp|rust)', 'python')
  .option('-o, --output <file>', 'Output file path')
  .option('--debug', 'Enable debug mode')
  .action(async (file, options) => {
    const spinner = ora('Compiling strategy...').start();
    
    try {
      // Read source file
      const sourcePath = path.resolve(file);
      if (!fs.existsSync(sourcePath)) {
        throw new Error(`File not found: ${sourcePath}`);
      }
      
      const source = fs.readFileSync(sourcePath, 'utf-8');
      
      // TODO: Parse and compile
      const generator = new TradingCodeGenerator({
        target: options.target,
        runtime: 'backtest',
        optimize: !options.debug,
        debug: options.debug
      });
      
      // For now, mock compilation
      spinner.succeed(chalk.green(`✓ Compiled ${file} to ${options.target}`));
      
      // Write output
      const outputPath = options.output || file.replace('.crowe', `.${options.target === 'python' ? 'py' : 'ts'}`);
      console.log(chalk.gray(`Output: ${outputPath}`));
      
    } catch (error: any) {
      spinner.fail(chalk.red(`Compilation failed: ${error.message}`));
      process.exit(1);
    }
  });

// Backtest command
program
  .command('backtest <file>')
  .description('Run backtest on a strategy')
  .option('-s, --start <date>', 'Start date (YYYY-MM-DD)', '2023-01-01')
  .option('-e, --end <date>', 'End date (YYYY-MM-DD)', '2023-12-31')
  .option('-c, --capital <amount>', 'Initial capital', '1000000')
  .option('--symbols <symbols>', 'Comma-separated symbols', 'AAPL,GOOGL,MSFT')
  .option('--data <source>', 'Data source (mock|csv|polygon)', 'mock')
  .action(async (file, options) => {
    const spinner = ora('Running backtest...').start();
    
    try {
      // Create backtest engine
      const engine = new BacktestEngine({
        start_date: options.start,
        end_date: options.end,
        initial_capital: parseFloat(options.capital),
        data_source: options.data,
        symbols: options.symbols.split(','),
        timeframe: 'DAY',
        commission: 0.001,
        slippage: 0.0005
      });
      
      // TODO: Load and add strategy
      // For now, create a mock strategy
      spinner.text = 'Loading strategy...';
      
      // Run backtest
      spinner.text = 'Running backtest...';
      const results = await engine.run();
      
      spinner.succeed(chalk.green('✓ Backtest completed'));
      
      // Display results
      console.log('\n' + chalk.bold('Backtest Results:'));
      console.log(chalk.gray('─'.repeat(40)));
      
      console.log(`Total Return: ${chalk.green((results.total_return * 100).toFixed(2) + '%')}`);
      console.log(`Annual Return: ${chalk.green((results.annual_return * 100).toFixed(2) + '%')}`);
      console.log(`Sharpe Ratio: ${chalk.yellow(results.sharpe_ratio.toFixed(2))}`);
      console.log(`Max Drawdown: ${chalk.red((results.max_drawdown * 100).toFixed(2) + '%')}`);
      console.log(`Win Rate: ${chalk.blue((results.win_rate * 100).toFixed(1) + '%')}`);
      console.log(`Total Trades: ${results.total_trades}`);
      
      console.log(chalk.gray('─'.repeat(40)));
      
    } catch (error: any) {
      spinner.fail(chalk.red(`Backtest failed: ${error.message}`));
      process.exit(1);
    }
  });

// Validate command
program
  .command('validate <file>')
  .description('Validate a CroweLang strategy file')
  .action(async (file) => {
    const spinner = ora('Validating strategy...').start();
    
    try {
      // Read and validate
      const sourcePath = path.resolve(file);
      const source = fs.readFileSync(sourcePath, 'utf-8');
      
      // TODO: Implement validation
      spinner.succeed(chalk.green(`✓ Strategy is valid`));
      
    } catch (error: any) {
      spinner.fail(chalk.red(`Validation failed: ${error.message}`));
      process.exit(1);
    }
  });

// New command - create new strategy from template
program
  .command('new <name>')
  .description('Create a new strategy from template')
  .option('-t, --template <template>', 'Template type (mean-reversion|momentum|market-making)', 'mean-reversion')
  .action(async (name, options) => {
    const spinner = ora('Creating strategy...').start();
    
    try {
      const template = getStrategyTemplate(options.template);
      const fileName = `${name}.crowe`;
      
      fs.writeFileSync(fileName, template.replace('{{NAME}}', name));
      
      spinner.succeed(chalk.green(`✓ Created ${fileName}`));
      console.log(chalk.gray(`Edit ${fileName} to customize your strategy`));
      
    } catch (error: any) {
      spinner.fail(chalk.red(`Failed to create strategy: ${error.message}`));
      process.exit(1);
    }
  });

// Watch command - compile on file changes
program
  .command('watch <file>')
  .description('Watch and compile on changes')
  .option('-t, --target <target>', 'Target language', 'python')
  .action(async (file, options) => {
    console.log(chalk.blue(`Watching ${file} for changes...`));
    
    const compile = () => {
      console.log(chalk.gray(`[${new Date().toLocaleTimeString()}] Compiling...`));
      // TODO: Compile logic
      console.log(chalk.green('✓ Compiled successfully'));
    };
    
    // Initial compile
    compile();
    
    // Watch for changes
    fs.watchFile(file, { interval: 1000 }, compile);
  });

// Info command - show system info
program
  .command('info')
  .description('Show CroweLang system information')
  .action(() => {
    console.log(chalk.bold('\nCroweLang System Information'));
    console.log(chalk.gray('─'.repeat(40)));
    console.log(`Version: ${chalk.green('0.1.0')}`);
    console.log(`Node: ${chalk.green(process.version)}`);
    console.log(`Platform: ${chalk.green(process.platform)}`);
    console.log(`Architecture: ${chalk.green(process.arch)}`);
    console.log(chalk.gray('─'.repeat(40)));
    console.log('\nAvailable Features:');
    console.log('  ✓ Strategy compilation');
    console.log('  ✓ Backtesting engine');
    console.log('  ✓ Mock data provider');
    console.log('  ○ Live trading (coming soon)');
    console.log('  ○ Real data feeds (coming soon)');
  });

// Helper function to get strategy templates
function getStrategyTemplate(type: string): string {
  const templates: Record<string, string> = {
    'mean-reversion': `// {{NAME}} - Mean Reversion Strategy
strategy {{NAME}} {
  params {
    lookback: int = 20
    zscore_entry: float = 2.0
    zscore_exit: float = 0.5
    position_size: float = 0.1
  }
  
  indicators {
    sma = SMA(close, lookback)
    std = StdDev(close, lookback)
    zscore = (close - sma) / std
  }
  
  signals {
    long_entry = zscore < -zscore_entry
    long_exit = zscore > -zscore_exit
    short_entry = zscore > zscore_entry
    short_exit = zscore < zscore_exit
  }
  
  rules {
    when (long_entry and not position) {
      buy(position_size * capital)
    }
    when (long_exit and position > 0) {
      sell(position)
    }
    when (short_entry and not position) {
      short(position_size * capital)
    }
    when (short_exit and position < 0) {
      cover(position)
    }
  }
  
  risk {
    max_position = 0.25 * capital
    stop_loss = 0.02
    daily_var_limit = 0.03
  }
}`,
    'momentum': `// {{NAME}} - Momentum Strategy
strategy {{NAME}} {
  params {
    momentum_period: int = 20
    entry_threshold: float = 0.05
    position_size: float = 0.1
  }
  
  indicators {
    momentum = (close - close[momentum_period]) / close[momentum_period]
    sma_volume = SMA(volume, 20)
  }
  
  signals {
    bullish = momentum > entry_threshold and volume > sma_volume
    bearish = momentum < -entry_threshold and volume > sma_volume
  }
  
  rules {
    when (bullish and not position) {
      buy(position_size * capital)
    }
    when (bearish and position > 0) {
      sell(position)
    }
  }
  
  risk {
    max_position = 0.3 * capital
    stop_loss = 0.03
    trailing_stop = 0.02
  }
}`,
    'market-making': `// {{NAME}} - Market Making Strategy
strategy {{NAME}} {
  params {
    spread_bps: float = 5.0
    max_inventory: float = 10000.0
    order_size: float = 100.0
    skew_factor: float = 0.5
  }
  
  indicators {
    mid_price = (best_bid + best_ask) / 2
    fair_value = EMA(mid_price, 10)
    volatility = StdDev(mid_price, 20)
    inventory_ratio = position / max_inventory
  }
  
  signals {
    quote_stale = time_since_last_quote > 1000
    inventory_full = abs(position) > max_inventory * 0.8
    high_volatility = volatility > historical_volatility * 2.0
  }
  
  rules {
    when (quote_stale or market_moved) {
      cancel_all_quotes()
      place_new_quotes()
    }
    when (inventory_full) {
      adjust_quote_sizes(inventory_ratio)
    }
  }
  
  risk {
    max_position = max_inventory
    max_daily_loss = 5000.0
    max_order_rate = 100
  }
}`
  };
  
  return templates[type] || templates['mean-reversion'];
}

// Parse and run
program.parse(process.argv);

// Show help if no command provided
if (!process.argv.slice(2).length) {
  program.outputHelp();
}