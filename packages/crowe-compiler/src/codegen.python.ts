import { CroweFile, Component, Store, Section, StateDecl, ComputedDecl, EffectDecl, ActionDecl, RenderBlock, StreamDecl, AIDecl } from './ast';
import { generateSourceMapForComponent, addSourceMapComment } from './source-map';

export interface PythonCodeGenOptions {
  sourceMaps?: boolean;
  sourceMapPath?: string;
  originalSource?: string;
  sourcePath?: string;
  croweTrade?: boolean; // Generate CroweTrade-compatible agents
}

/**
 * Generate Python code for CroweTrade financial agent ecosystem
 */
export function generatePython(ast: CroweFile, options: PythonCodeGenOptions = {}): string {
  const lines: string[] = [];
  
  // Import statements
  lines.push('"""Generated by CroweLang Compiler for CroweTrade"""');
  lines.push('import asyncio');
  lines.push('import json');
  lines.push('from dataclasses import dataclass, field');
  lines.push('from typing import Dict, List, Optional, Any, Callable');
  lines.push('from datetime import datetime, timedelta');
  lines.push('import numpy as np');
  lines.push('import pandas as pd');
  
  if (options.croweTrade) {
    lines.push('');
    lines.push('# CroweTrade imports');
    lines.push('from crowetrade.contracts import BaseAgent, AgentContract');
    lines.push('from crowetrade.execution import ExecutionEngine, Order, Fill');
    lines.push('from crowetrade.risk import RiskManager, PositionLimit, VaRLimit');
    lines.push('from crowetrade.data import MarketData, Bar, Tick, OrderBook');
    lines.push('from crowetrade.indicators import *');
  }
  
  lines.push('');
  
  // Process strategies (components in Crowe that are financial strategies)
  const strategies = ast.components.filter(c => isStrategy(c));
  const agents = ast.components.filter(c => isAgent(c));
  
  // Generate strategy classes
  for (const strategy of strategies) {
    emitStrategyClass(strategy, lines, options);
    lines.push('');
  }
  
  // Generate agent classes
  for (const agent of agents) {
    emitAgentClass(agent, lines, options);
    lines.push('');
  }
  
  // Generate stores as shared state managers
  if (ast.stores) {
    for (const store of ast.stores) {
      emitStoreClass(store, lines, options);
      lines.push('');
    }
  }
  
  // Add main execution if standalone
  if (!options.croweTrade) {
    lines.push('if __name__ == "__main__":');
    lines.push('    # Example usage');
    lines.push('    asyncio.run(main())');
  }
  
  let result = lines.join('\n');
  
  // Add source maps if requested
  if (options.sourceMaps && options.originalSource && options.sourcePath) {
    const sourceMap = generateSourceMapForComponent(
      options.originalSource,
      result,
      options.sourcePath
    );
    
    if (options.sourceMapPath) {
      result = addSourceMapComment(result, options.sourceMapPath);
    }
  }
  
  return result;
}

function isStrategy(comp: Component): boolean {
  // Check if component has strategy-specific sections
  return comp.sections.some(s => 
    ['indicators', 'signals', 'rules', 'risk', 'params'].includes(s.kind)
  );
}

function isAgent(comp: Component): boolean {
  // Check if component name contains 'Agent' or has agent-specific patterns
  return comp.name.includes('Agent') || 
         comp.sections.some(s => ['contract', 'behavior'].includes(s.kind));
}

function emitStrategyClass(comp: Component, out: string[], options: PythonCodeGenOptions) {
  const className = comp.name;
  const baseClass = options.croweTrade ? 'BaseAgent' : 'object';
  
  out.push(`class ${className}(${baseClass}):`);
  out.push(`    """${className} - Generated from CroweLang"""`)
  out.push('');
  
  // Constructor
  out.push('    def __init__(self, **kwargs):');
  out.push(`        super().__init__(name="${className}", **kwargs)`);
  
  // Extract params section
  const paramsSection = comp.sections.find(s => s.kind === 'params');
  if (paramsSection) {
    out.push('        # Strategy parameters');
    emitParams(paramsSection, out);
  }
  
  // Extract indicators
  const indicatorsSection = comp.sections.find(s => s.kind === 'indicators');
  if (indicatorsSection) {
    out.push('        # Technical indicators');
    out.push('        self.indicators = {}');
  }
  
  // Risk management
  const riskSection = comp.sections.find(s => s.kind === 'risk');
  if (riskSection && options.croweTrade) {
    out.push('        # Risk management');
    out.push('        self.risk_manager = RiskManager()');
    emitRiskLimits(riskSection, out);
  }
  
  out.push('');
  
  // Process market data method
  out.push('    async def on_bar(self, bar: Bar):');
  out.push('        """Process new bar data"""');
  
  // Calculate indicators
  if (indicatorsSection) {
    emitIndicatorCalculations(indicatorsSection, out);
  }
  
  // Check signals
  const signalsSection = comp.sections.find(s => s.kind === 'signals');
  if (signalsSection) {
    out.push('        # Evaluate signals');
    emitSignalEvaluation(signalsSection, out);
  }
  
  // Execute rules
  const rulesSection = comp.sections.find(s => s.kind === 'rules');
  if (rulesSection) {
    out.push('        # Execute trading rules');
    emitTradingRules(rulesSection, out);
  }
  
  out.push('');
  
  // Add event handlers
  const eventsSection = comp.sections.find(s => s.kind === 'events');
  if (eventsSection) {
    emitEventHandlers(eventsSection, out, options);
  }
}

function emitAgentClass(comp: Component, out: string[], options: PythonCodeGenOptions) {
  const className = comp.name;
  
  out.push(`@dataclass`);
  out.push(`class ${className}(AgentContract):`);
  out.push(`    """${className} - CroweTrade Agent"""`)
  out.push('');
  
  // State variables
  for (const section of comp.sections) {
    if (section.kind === 'state') {
      const state = section as StateDecl;
      const pyType = mapTypeToPython(state.type);
      const defaultValue = state.init || getDefaultValue(pyType);
      out.push(`    ${state.name}: ${pyType} = ${defaultValue}`);
    }
  }
  
  out.push('');
  
  // Methods for actions
  for (const section of comp.sections) {
    if (section.kind === 'action') {
      const action = section as ActionDecl;
      out.push(`    async def ${action.name}(self${action.params ? ', ' + action.params : ''}):`);
      out.push(`        """${action.name} action"""`);
      const body = pythonifyBody(action.body);
      out.push(indent(body, 2));
      out.push('');
    }
  }
  
  // Computed properties
  for (const section of comp.sections) {
    if (section.kind === 'computed') {
      const computed = section as ComputedDecl;
      out.push(`    @property`);
      out.push(`    def ${computed.name}(self):`);
      out.push(`        """Computed: ${computed.name}"""`);
      const body = pythonifyBody(computed.body);
      out.push(indent(body, 2));
      out.push('');
    }
  }
}

function emitStoreClass(store: Store, out: string[], options: PythonCodeGenOptions) {
  out.push(`class ${store.name}Store:`);
  out.push(`    """${store.name} - Shared State Store"""`)
  out.push('');
  out.push('    def __init__(self):');
  
  // Initialize state
  for (const section of store.sections) {
    if (section.kind === 'state') {
      const state = section as StateDecl;
      const pyType = mapTypeToPython(state.type);
      const defaultValue = state.init || getDefaultValue(pyType);
      out.push(`        self.${state.name} = ${defaultValue}`);
    }
  }
  
  out.push('        self._observers = []');
  out.push('');
  
  // Add observer pattern
  out.push('    def subscribe(self, callback):');
  out.push('        self._observers.append(callback)');
  out.push('');
  out.push('    def notify(self):');
  out.push('        for observer in self._observers:');
  out.push('            observer(self)');
  out.push('');
  
  // Actions that modify state
  for (const section of store.sections) {
    if (section.kind === 'action') {
      const action = section as ActionDecl;
      out.push(`    def ${action.name}(self${action.params ? ', ' + action.params : ''}):`);
      const body = pythonifyBody(action.body);
      out.push(indent(body, 2));
      out.push('        self.notify()');
      out.push('');
    }
  }
}

function emitParams(section: Section, out: string[]) {
  // Parse params block and generate Python assignments
  const body = (section as any).body || '';
  const lines = body.split('\n').filter((l: string) => l.trim());
  
  for (const line of lines) {
    const match = line.match(/(\w+)\s*:\s*(\w+)\s*=\s*(.+)/);
    if (match) {
      const [, name, type, value] = match;
      const pyType = mapTypeToPython(type);
      out.push(`        self.${name} = kwargs.get('${name}', ${value})`);
    }
  }
}

function emitIndicatorCalculations(section: Section, out: string[]) {
  const body = (section as any).body || '';
  const lines = body.split('\n').filter((l: string) => l.trim());
  
  for (const line of lines) {
    const match = line.match(/(\w+)\s*=\s*(.+)/);
    if (match) {
      const [, name, expr] = match;
      const pyExpr = pythonifyExpression(expr);
      out.push(`        self.indicators['${name}'] = ${pyExpr}`);
    }
  }
}

function emitSignalEvaluation(section: Section, out: string[]) {
  const body = (section as any).body || '';
  const lines = body.split('\n').filter((l: string) => l.trim());
  
  for (const line of lines) {
    const match = line.match(/(\w+)\s*=\s*(.+)/);
    if (match) {
      const [, name, expr] = match;
      const pyExpr = pythonifyExpression(expr);
      out.push(`        ${name} = ${pyExpr}`);
    }
  }
}

function emitTradingRules(section: Section, out: string[]) {
  const body = (section as any).body || '';
  const whenBlocks = body.match(/when\s*\(([^)]+)\)\s*\{([^}]+)\}/g) || [];
  
  for (const block of whenBlocks) {
    const match = block.match(/when\s*\(([^)]+)\)\s*\{([^}]+)\}/);
    if (match) {
      const [, condition, action] = match;
      const pyCondition = pythonifyExpression(condition);
      const pyAction = pythonifyBody(action);
      out.push(`        if ${pyCondition}:`);
      out.push(indent(pyAction, 3));
    }
  }
}

function emitRiskLimits(section: Section, out: string[]) {
  const body = (section as any).body || '';
  const lines = body.split('\n').filter((l: string) => l.trim());
  
  for (const line of lines) {
    const match = line.match(/(\w+)\s*=\s*(.+)/);
    if (match) {
      const [, name, value] = match;
      if (name === 'max_position') {
        out.push(`        self.risk_manager.add_limit(PositionLimit(${value}))`);
      } else if (name === 'daily_var_limit') {
        out.push(`        self.risk_manager.add_limit(VaRLimit(${value}))`);
      } else {
        out.push(`        self.risk_manager.${name} = ${value}`);
      }
    }
  }
}

function emitEventHandlers(section: Section, out: string[], options: PythonCodeGenOptions) {
  const body = (section as any).body || '';
  const handlers = body.match(/on_\w+\s*\([^)]*\)\s*\{[^}]+\}/g) || [];
  
  for (const handler of handlers) {
    const match = handler.match(/on_(\w+)\s*\(([^)]*)\)\s*\{([^}]+)\}/);
    if (match) {
      const [, event, params, handlerBody] = match;
      out.push(`    async def on_${event}(self${params ? ', ' + params : ''}):`);
      out.push(`        """Handle ${event} event"""`);
      const pyBody = pythonifyBody(handlerBody);
      out.push(indent(pyBody, 2));
      out.push('');
    }
  }
}

function mapTypeToPython(type?: string): string {
  if (!type) return 'Any';
  const typeMap: Record<string, string> = {
    'int': 'int',
    'float': 'float',
    'string': 'str',
    'boolean': 'bool',
    'datetime': 'datetime',
    'Bar': 'Bar',
    'Tick': 'Tick',
    'OrderBook': 'OrderBook',
    'Order': 'Order',
    'Fill': 'Fill'
  };
  
  // Handle arrays
  if (type.endsWith('[]')) {
    const baseType = type.slice(0, -2);
    return `List[${mapTypeToPython(baseType)}]`;
  }
  
  // Handle maps
  if (type.startsWith('Map<')) {
    const match = type.match(/Map<([^,]+),\s*([^>]+)>/);
    if (match) {
      const [, keyType, valueType] = match;
      return `Dict[${mapTypeToPython(keyType)}, ${mapTypeToPython(valueType)}]`;
    }
  }
  
  return typeMap[type] || type;
}

function getDefaultValue(pyType: string): string {
  if (pyType === 'int') return '0';
  if (pyType === 'float') return '0.0';
  if (pyType === 'str') return '""';
  if (pyType === 'bool') return 'False';
  if (pyType.startsWith('List')) return '[]';
  if (pyType.startsWith('Dict')) return '{}';
  if (pyType === 'datetime') return 'datetime.now()';
  return 'None';
}

function pythonifyExpression(expr: string): string {
  // Convert CroweLang expressions to Python
  return expr
    .replace(/\band\b/g, 'and')
    .replace(/\bor\b/g, 'or')
    .replace(/\bnot\b/g, 'not')
    .replace(/\btrue\b/g, 'True')
    .replace(/\bfalse\b/g, 'False')
    .replace(/\bnull\b/g, 'None')
    .replace(/\$\{([^}]+)\}/g, 'f"{$1}"'); // Template literals
}

function pythonifyBody(body: string): string {
  const lines = body.split('\n').map(line => line.trim()).filter(line => line);
  return lines.map(line => {
    // Convert common patterns
    line = pythonifyExpression(line);
    
    // Handle function calls
    line = line.replace(/^(\w+)\((.*)\);?$/, 'await self.$1($2)');
    
    // Handle assignments
    line = line.replace(/^const\s+(\w+)\s*=\s*(.+);?$/, '$1 = $2');
    line = line.replace(/^let\s+(\w+)\s*=\s*(.+);?$/, '$1 = $2');
    
    // Handle returns
    line = line.replace(/^return\s+(.+);?$/, 'return $1');
    
    // Remove semicolons
    line = line.replace(/;$/, '');
    
    return line;
  }).join('\n');
}

function indent(text: string, level: number): string {
  const spaces = '    '.repeat(level);
  return text.split('\n').map(line => spaces + line).join('\n');
}